#include <string.h>
#include <math.h>
#include "main.h"
#include "gpio.h"
#include "usart.h"
#include "tim.h"
#include "stm32h7xx_nucleo_144.h"
#include "usb_device.h"
#include "usbd_cdc_if.h"
#include "JSB_General.h"
#include "JSB_DWT.h"
#include "usb_diagnostics.h"
#include "go.h"

#define TxPacket_Data_NumBytes (1024) /*!!! Originally 20480. 8000 avoids pipe error 9.*/
typedef struct
{
  GUID_t FormatID;
  uint32_t PacketNumber;
  uint32_t NumBytes;
  uint8_t Data[TxPacket_Data_NumBytes];
} TxPacket_t;

static TxPacket_t TxPacket;
static uint32_t NumPacketsSent = 0;

extern USBD_HandleTypeDef hUsbDeviceFS;

static uint32_t TimerCallNumber = 0;

static uint8_t USBLinkBroken = 0;

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  float AbsoluteTime = HAL_GetTick() / 1000.0f;

  if (htim == &htim3)
  {
    if (hUsbDeviceFS.dev_state != USBD_STATE_CONFIGURED)
    {
      printf("JSB: Device not configured.\r\n");
      return;
    }

    USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)(hUsbDeviceFS.pClassData); // To do: Check hUsbDeviceFS.pClassData is not NULL!!!
    if (!hcdc)
    {
      printf("JSB: hCDC is zero!\r\n");
      return;
    }

    if ((hcdc->TxState != 0) && (hcdc->TxState != 1))
    {
      printf("JSB: TxState is %08lx!\r\n", hcdc->TxState);
    }
    else if (!BSP_PB_GetState(BUTTON_USER))
    {
      if (hcdc->TxState)
      {
        uint32_t StartTime_Cycles = DWT_GetNumProcessorClockCycles();
        while (hcdc->TxState) {} // Wait for transmission to complete.
        uint32_t EndTime_Cycles = DWT_GetNumProcessorClockCycles();
        float WaitTime = DWT_GetCycleTime() * (EndTime_Cycles - StartTime_Cycles);

        printf("JSB: %0.3f Waited for %0.6f seconds.\r\n", AbsoluteTime, WaitTime);
      }

      // Configure TxPacket.
      TxPacket.PacketNumber = NumPacketsSent;

      uint32_t StartTime_Cycles = DWT_GetNumProcessorClockCycles();
      while (CDC_Transmit_FS((void *)&TxPacket, sizeof(TxPacket)) == USBD_BUSY)
      {
        printf("JSB: Line busy\r\n");
      }

      // Wait for transmission to complete. If too long then assume link is broken.
      while (hcdc->TxState)
      {
        printf("JSB: TxState: %d\r\n", (int)hcdc->TxState);

        uint32_t CurrentTime_Cycles = DWT_GetNumProcessorClockCycles();
        float TransmissionTime = DWT_GetCycleTime() * (CurrentTime_Cycles - StartTime_Cycles);
        if (TransmissionTime > 60.0) // Increased from 1 second to 1 minute.
        {
          USBLinkBroken = 1;
          return;
        }

        if (TransmissionTime > 0.1)
          printf("JSB: Waiting for transmission to complete.\r\n");
      }

      ++NumPacketsSent;
    }
  }

  ++TimerCallNumber;
}

static void Go_JSB()
{
  // Configure TxPacket.
  StringToGUID("{10E7F8C6-1177-44D9-A318-CF74E9C28B76}", &TxPacket.FormatID);
  TxPacket.PacketNumber = 0;
  TxPacket.NumBytes = TxPacket_Data_NumBytes;
  for (int DataByteIndex = 0; DataByteIndex < TxPacket_Data_NumBytes; ++DataByteIndex)
    TxPacket.Data[DataByteIndex] = 64 + (DataByteIndex % 32);

  printf("JSB: Waiting for user button to be pressed.\r\n");
  while (!BSP_PB_GetState(BUTTON_USER)) {}
  printf("JSB: User button pressed.\r\n");

  HAL_TIM_Base_Start_IT(&htim3);

  while (1)
  {
    if (USBLinkBroken)
    {
      USBLinkBroken = 0;
      printf("JSB: USB link assumed broken.\r\n");
      printf("JSB: Reinitializing USB.\r\n");

      MX_USB_DEVICE_Init();
    }

    HAL_Delay(50);
  }
}

static void Go_PJB()
{
  diagnostics_init();

  printf("Waiting for user button to be pressed.\r\n");
  while (!BSP_PB_GetState(BUTTON_USER)) {}
  printf("User button pressed.\r\n");

  while (1)
  {
    usb_flush();

    // Added by JSB:
    // Wait for transmission to complete. If too long then assume link is broken.
    USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)(hUsbDeviceFS.pClassData); // To do: Check hUsbDeviceFS.pClassData is not NULL!!!
    while (hcdc->TxState)
    {
    }
  }
}

void Go()
{
  Enable_DWT_Delay();

  BSP_PB_Init(BUTTON_USER, BUTTON_MODE_GPIO);
  BSP_LED_Init(LED_GREEN);

  Go_JSB();
  //Go_PJB();
}
